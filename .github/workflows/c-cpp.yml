name: C/C++ CI

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ice1
    # the next section is for leveraging a container on the runner, the example
    # below shows one called hell-test that is self hosted on the runner.  It;s
    # commented out because of experiments I'm doing with various ways of using
    # containers, runner services, etc.  Without it, for example, 2 runners as
    # services on the same bare metal will likley step on each other because they
    # still share the underlying filesystem.  So this is 2 ways of getting container
    # isolattion, use the container keyword below and have the container pre-configured
    # for our CI work and count on the runner being there likely as a service.  OR,
    # use containers as runners that also do double duty with actual testing. Pretty syre
    # the latter won't work with the stuff below uncommented because docker in docker I think
    # has issues but haven't looked into all that much yet.
    #container:
    #  image: localhost:5000/hell-test:1.0.0

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v3

      # Runs a single command using the runners shell
      - name: Run a one-line script
        run: echo RUN THIS!

      - name: Compile
        run: gcc hello.c

      - name: Runit
        run: ./a.out
        
      # Runs a set of commands using the runners shell
      - name: Run a multi-line script
        run: |
          echo Add other actions to build,
          echo test, and deploy your project.
          ./a.out
